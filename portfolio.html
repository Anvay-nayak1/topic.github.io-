<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Bike Management System</title>
    <link rel="stylesheet" href="styleportf.css">
</head>
<body>
    <header>
        <h1>E-Bike Management System</h1>
        <p>Course Project Portfolio</p>
    </header>

 <h2>ðŸ“š Course Introduction</h2>

    
    <section id="home">
        <h2>Introduction</h2>
        <p>
This course focuses on understanding data structures and algorithms and their real-time applications. You will explore various concepts like iteration, recursion, backtracking, and optimization while solving real-world problems, particularly in E-Bike management systems.</p>
        <p>By learning these concepts, you will gain insights into how data structures like trees, graphs, and arrays, along with algorithm design techniques, are implemented in practical scenarios.</p>
    </section>

    <section id="course-project">
        <h2>Course Project: E-Bike Management System</h2>
        <p><strong>Problem Space:</strong> Our project addressed challenges in urban mobility, like traffic congestion and inefficient bike-sharing systems. We identified docking station overcrowding and lack of real-time updates as key issues.</p>
        <p>To address these, we designed a system featuring real-time tracking, automated reports, and a feedback mechanism. This approach improved resource allocation and user experience, making the solution scalable for expanding cities.</p>
        <p><strong>Problem Definition:</strong> Develop a smart E-Bike Management System to enhance bike availability, optimize docking station usage, and ensure user satisfaction. Key features included bike rentals, returns, and premium subscriptions, while maintaining scalability.</p>
        <p><strong>Team Details:</strong></p>
        <table border="1" cellspacing="0" cellpadding="5">
            <tr>
                <th>Sl.No.</th>
                <th>Roll No.</th>
                <th>Name</th>
                <th>Function</th>
                <th>Business Case Study</th>
            </tr>
            <tr>
                <td>1</td>
                <td>143</td>
                <td>Anvay</td>
                <td>Feedback and Reporting System</td>
                <td>Ensuring secure and seamless onboarding of users.</td>
            </tr>
            <tr>
                <td>2</td>
                <td>103</td>
                <td>Nithish Palankar</td>
                <td>Docking Station Management</td>
                <td>Optimizing the management of docking stations to ensure bike availability.</td>
            </tr>
            <tr>
                <td>3</td>
                <td>135</td>
                <td>Rehan </td>
                <td>User Management, Bike Rental/Return</td>
                <td>Collecting and analyzing user feedback to improve system functionality.</td>
            </tr>
            <tr>
                <td>4</td>
                <td>142</td>
                <td>Desaigouda</td>
                <td>Route Optimization and Shortest Path Algorithms</td>
                <td>Enabling users to find the fastest routes between docking stations, enhancing convenience and usability.</td>
            </tr>
        </table>
<h3>Algorithm for e-bike managment system</h3>
        <pre><code>#include <iostream>
#include <unordered_map>
#include <climits>

using namespace std;

// Data structure to represent a docking station
struct DockingStation {
    int id;
    string name;
    int capacity;
    int availableBikes;
};

// HashMap to store docking station data
unordered_map<int, DockingStation> stations;

// Function to update availability
void updateAvailability(int stationId, int bikes) {
    if (stations.find(stationId) != stations.end()) {
        stations[stationId].availableBikes += bikes;
        if (stations[stationId].availableBikes > stations[stationId].capacity) {
            stations[stationId].availableBikes = stations[stationId].capacity;
        } else if (stations[stationId].availableBikes < 0) {
            stations[stationId].availableBikes = 0;
        }
    } else {
        cout << "Station ID not found." << endl;
    }
}

// Constant pricing function
double getPrice() {
    const double constantPrice = 10.0; // Example fixed price
    return constantPrice;
}

// Dijkstra's Algorithm using adjacency matrix
void dijkstra(int graph[3][3], int src, int V) {
    int dist[V];               // Array to hold the shortest distances
    bool visited[V] = {false}; // Visited nodes

    // Initialize distances as infinite and visited as false
    for (int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
    }
    dist[src] = 0;

    for (int count = 0; count < V - 1; count++) {
        // Find the minimum distance vertex from the unvisited vertices
        int minDist = INT_MAX, u = -1;
        for (int v = 0; v < V; v++) {
            if (!visited[v] && dist[v] < minDist) {
                minDist = dist[v];
                u = v;
            }
        }

        // Mark the chosen vertex as visited
        visited[u] = true;

        // Update the distances of adjacent vertices
        for (int v = 0; v < V; v++) {
            if (!visited[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];
            }
        }
    }

    // Print the shortest distances from the source
    cout << "Shortest distances from station " << src << ":" << endl;
    for (int i = 0; i < V; i++) {
        cout << "To station " << i << ": " << dist[i] << endl;
    }
}

// Main function
int main() {
    // Initialize docking stations
    stations[1] = {1, "Station A", 20, 10};
    stations[2] = {2, "Station B", 15, 5};
    stations[3] = {3, "Station C", 25, 8};

    // Update bike availability
    updateAvailability(1, -3); // Rent 3 bikes from Station A
    updateAvailability(2, 2);  // Return 2 bikes to Station B

    // Display updated availability
    cout << "Station A available bikes: " << stations[1].availableBikes << endl;
    cout << "Station B available bikes: " << stations[2].availableBikes << endl;

    // Constant pricing example
    cout << "Bike rental price: $" << getPrice() << endl;

    // Graph representation of distances (using adjacency matrix)
    int V = 3; // Number of stations
    int graph[3][3] = {
        {0, 5, 7}, // Station 0 to 1: 5, 0 to 2: 7
        {5, 0, 3}, // Station 1 to 2: 3
        {7, 3, 0}  // Station 2 back to others
    };

    // Calculate shortest distances using Dijkstra's Algorithm
    dijkstra(graph, 0, V);

    return 0;
}
</code></pre>

    </section>
    <section id="learning-reflections">
        <h2>Course Learning Reflections</h2>
        <ol>
            <li><strong>Problems in Nature: Iteration, Recursion, and Backtracking</strong>
                <p>Nature often presents us with problems that require different approaches to solve. For example, iteration helps in handling repetitive tasks, like processing large datasets one step at a time. Recursion, on the other hand, is ideal for problems that have a natural "divide-and-conquer" structure, like calculating Fibonacci numbers or solving Tower of Hanoi. Backtracking shines in scenarios where we need to explore all possibilities, such as solving a Sudoku puzzle or navigating a maze. These techniques teach us how to adapt our thinking to match the problem's structure.</p>
            </li>
            <li><strong>Space and Time Efficiency</strong>
                <p>Space and time efficiency are at the heart of algorithm design. Imagine using an app that takes forever to load or crashes due to memory issuesâ€”this is why efficiency matters. Time efficiency ensures tasks are completed quickly, while space efficiency makes sure memory usage is minimal. Problems are categorized based on their complexity, such as linear (O(n)), quadratic (O(nÂ²)), or even exponential (O(2^n)). Understanding these growth patterns helps us select the right approach, ensuring scalability and performance.</p>
            </li>
<li><strong>Design Principles from Chapter 2</strong>
                <p>One of the biggest takeaways was learning how to simplify complex problems using design principles:
                <ul>
                    <li>Decomposition: Breaking problems into smaller parts, making them easier to solve.</li>
                    <li>Abstraction: Focusing on the important details while ignoring irrelevant complexities.</li>
                    <li>Pattern Recognition: Identifying recurring solutions, like using sliding windows for substring problems.</li>
                </ul>
                These principles arenâ€™t just technicalâ€”theyâ€™re practical tools for approaching challenges in everyday life.</p>
            </li>
            <li><strong>Hierarchical Data and Tree Structures</strong>
                <p>Trees are everywhere in computing, from file systems to decision-making processes. We studied different types of trees and how they solve real-world problems:
                <ul>
                    <li>Binary Search Trees (BSTs): Efficient for searching and sorting.</li>
                    <li>AVL Trees: Self-balancing to maintain efficiency.</li>
                    <li>2-3 Trees and Red-Black Trees: Optimized for faster insertion and deletion.</li>
                    <li>Heaps: Used in priority queues for scheduling tasks.</li>
                    <li>Tries: Perfect for autocomplete features in search engines.</li>
                </ul>
                Understanding these structures helped us realize how hierarchical data can be efficiently managed and manipulated.</p>
            </li>
            <li><strong>Array Query Algorithms</strong>
                <p>Arrays might seem simple, but theyâ€™re incredibly powerful. Query algorithms like prefix sums, segment trees, and Fenwick trees make it possible to answer complex range-based questions in milliseconds. For example, theyâ€™re used in applications like calculating monthly expenses in financial apps or determining the fastest route in navigation systems. These algorithms teach us how to turn raw data into actionable insights.</p>
            </li>
            <li><strong>Trees vs. Graphs</strong>
                <p>While trees are hierarchical, graphs represent connections, making them ideal for modeling relationships like social networks or city maps. Tree traversals (in-order, pre-order, post-order) are great for structured data, while graph traversals (DFS, BFS) excel at finding paths or connected components. Graphs are more versatile, but trees simplify tasks when hierarchy is key.</p>
            </li>
            <li><strong>Sorting and Searching Algorithms</strong>
                <p>Sorting and searching algorithms are the backbone of efficient systems:
                <ul>
                    <li>Sorting: Algorithms like quicksort and merge sort help organize data, making retrieval faster.</li>
                    <li>Searching: Binary search drastically reduces the time to find an item in a sorted list, much like how search engines return results almost instantly.</li>
                </ul>
                These techniques make systems intuitive and responsive.</p>
            </li>
            <li><strong>Graph Algorithms: Spanning Trees and Shortest Paths</strong>
                <p>Graph algorithms bring real-world connectivity problems to life:
                <ul>
                    <li>Spanning Trees: Algorithms like Kruskalâ€™s and Primâ€™s help minimize costs, such as laying cables for a network.</li>
                    <li>Shortest Paths: Dijkstraâ€™s and Bellman-Ford algorithms are critical for navigation systems like Google Maps, ensuring we always find the quickest route.</li>
                </ul>
                These algorithms show us how abstract problems can have tangible applications in daily life.</p>
            </li>
            <li><strong>Algorithm Design Techniques</strong>
                <p>Throughout the course, we explored various design techniques:
                <ul>
                    <li>Divide and Conquer: Splitting problems into smaller parts, like merge sort.</li>
                    <li>Dynamic Programming: Storing intermediate results to avoid redundant calculations, as seen in resource optimization.</li>
                    <li>Greedy Algorithms: Making locally optimal choices for global solutions, like in Kruskalâ€™s algorithm.</li>
                    <li>Backtracking: Exploring all possibilities, perfect for puzzles and decision-making problems.</li>
                </ul>
                Each technique has its strengths, and choosing the right one often depends on the problem at hand.</p>
            </li>
                    
</ol>

        <h3>Thought-Provoking Questions</h3>
        <ul>
            <li><strong>How do you determine the most efficient approach?</strong>
                <p>By analyzing the problemâ€™s constraints and testing different strategies, we can evaluate which algorithm offers the best balance of speed and memory usage.</p>
            </li>
            <li><strong>How do you balance conflicting constraints?</strong>
                <p>During our E-Bike Management System project, we had to balance user-friendly features with system scalability. Prioritizing core functionalities first helped us find this balance.</p>
            </li>
            <li><strong>What criteria do you use to evaluate effectiveness?</strong>
                <p>A solution is effective if it solves the problem, handles edge cases, and performs well under stress. For example, our shortest path algorithm was tested with both small and large datasets.</p>
            </li>
            <li><strong>How do you adapt to unforeseen challenges?</strong>
                <p>Flexibility is key. When we faced an issue with bike availability simulations, we switched to a randomization approach to mimic real-world conditions.</p>
            </li>
            <li><strong>When do you prioritize simplicity over optimization?</strong>
                <p>For features like user feedback, simplicity was prioritized to keep the code maintainable. Optimization was reserved for performance-critical areas like routing.</p>
            </li>
            <li><strong>How does breaking down a problem help?</strong>
                <p>Decomposing the E-Bike System into user and admin modules made the development process smoother and more manageable.</p>
            </li>
            <li><strong>How do you identify trade-offs between solutions?</strong>
                <p>For example, we compared Dijkstraâ€™s and Bellman-Ford algorithms. Dijkstraâ€™s was faster but required non-negative weights, while Bellman-Ford handled negative weights but was slower.</p>
            </li>
        </ul>
    </section>

    <footer>
        <p>&copy; 2025 E-Bike Management Portfolio</p>
    </footer>
</body>
</html>
